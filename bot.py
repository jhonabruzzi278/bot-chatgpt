#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bot de chat con OpenAI con soporte para documentos.
"""

import logging
from typing import Dict, List
import asyncio
from time import sleep

from telegram import Update, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters
from telegram.constants import ChatAction
from telegram.error import NetworkError, RetryAfter, TimedOut, BadRequest

# Importar manejador de documentos
from document_handler import document_handler

from config.settings import (
    ensure_config, TELEGRAM_BOT_TOKEN, LOG_FORMAT, LOG_LEVEL,
    OPENAI_API_KEY, OPENAI_MODEL, SYSTEM_PROMPT, MAX_TOKENS, 
    TEMPERATURE, MAX_HISTORY_MESSAGES, is_user_authorized, setup_rotating_logger
)

from openai import OpenAI
import openai

# Configurar logging con rotaci√≥n autom√°tica
logger = setup_rotating_logger("chat-bot", "chat-bot.log")

# Cliente OpenAI
client = OpenAI(api_key=OPENAI_API_KEY)

# Memoria de conversaci√≥n en RAM por usuario
conversations: Dict[int, List[dict]] = {}

# Configuraci√≥n personalizada por usuario
user_configs: Dict[int, Dict] = {}

# Modelos v√°lidos de OpenAI (lista centralizada)
VALID_OPENAI_MODELS = ["gpt-4o-mini", "gpt-4o", "gpt-3.5-turbo"]

# Modos de respuesta disponibles
RESPONSE_MODES = {
    "ü§ñ Formal": "Adopta un tono profesional, corporativo y altamente estructurado. Utiliza lenguaje t√©cnico apropiado, evita contracciones y expresiones coloquiales. Organiza tus respuestas con claridad usando p√°rrafos bien definidos. Mant√©n objetividad y neutralidad en todo momento. Ideal para correspondencia empresarial, documentos oficiales, presentaciones corporativas y contextos donde se requiere m√°xima profesionalidad y seriedad.",
    
    "üòä Casual": "Comun√≠cate de manera relajada, amigable y natural, como si conversaras con un amigo cercano. Usa un lenguaje sencillo y cercano, puedes incluir emojis ocasionales para expresar emociones. Est√° bien usar contracciones (ej: 'no es' ‚Üí 'no'), expresiones coloquiales y un tono m√°s personal. S√© c√°lido, emp√°tico y accesible. Perfecto para conversaciones informales, consejos personales y crear un ambiente confortable.",
    
    "üéì Acad√©mico": "Proporciona respuestas exhaustivas, rigurosas y educativas con profundidad acad√©mica. Incluye definiciones precisas, contexto hist√≥rico cuando sea relevante, m√∫ltiples perspectivas del tema, y referencias a conceptos relacionados. Utiliza terminolog√≠a especializada y t√©cnica apropiada para el campo de estudio. Estructura tus explicaciones de lo general a lo espec√≠fico. Ideal para estudiantes, investigadores, papers acad√©micos y aprendizaje profundo de temas complejos.",
    
    "‚ö° Conciso": "Elimina toda informaci√≥n superflua y ve directamente al grano. M√°ximo 2-3 oraciones por respuesta. Sin introducciones, sin contexto adicional innecesario, sin elaboraciones extensas. Presenta solo los hechos esenciales, datos clave o la respuesta directa a la pregunta. Usa frases cortas y precisas. Perfecto para cuando necesitas respuestas r√°pidas, consultas urgentes o informaci√≥n espec√≠fica sin rodeos.",
    
    "üíº Ejecutivo": "Estructura tus respuestas como un resumen ejecutivo profesional. Comienza con la conclusi√≥n o punto principal m√°s importante. Usa bullets points y numeraci√≥n para organizar informaci√≥n clave. Enf√≥cate en insights accionables, m√©tricas relevantes, y decisiones estrat√©gicas. Destaca riesgos, oportunidades y recomendaciones concretas. Elimina detalles excesivos y mant√©n el enfoque en lo que importa para la toma de decisiones. Ideal para reportes de negocio, presentaciones ejecutivas y an√°lisis estrat√©gicos.",
    
    "üé® Creativo": "Expresa ideas de forma imaginativa, original y art√≠stica. Usa met√°foras v√≠vidas, analog√≠as creativas, lenguaje descriptivo y po√©tico cuando sea apropiado. No temas explorar comparaciones inusuales o perspectivas √∫nicas. S√© expresivo, emotivo y busca formas innovadoras de explicar conceptos. Pinta im√°genes mentales con tus palabras. Perfecto para brainstorming, storytelling, contenido creativo, marketing y cuando necesitas inspiraci√≥n o perspectivas frescas.",
    
    "üë®‚Äçüíª T√©cnico": "Proporciona respuestas con m√°xima precisi√≥n t√©cnica y rigor especializado. Incluye detalles de implementaci√≥n, arquitectura, consideraciones de rendimiento, limitaciones t√©cnicas y mejores pr√°cticas del campo. Usa terminolog√≠a espec√≠fica de la industria sin simplificaciones. Menciona versiones de software, especificaciones t√©cnicas, est√°ndares relevantes y posibles edge cases. Ideal para desarrolladores, ingenieros, sysadmins, arquitectos de software y profesionales t√©cnicos que necesitan informaci√≥n detallada y precisa.",
    
    "üßí Simple": "Explica todo como si tu audiencia tuviera 10 a√±os de edad. Usa vocabulario extremadamente simple y cotidiano. Evita completamente jerga t√©cnica, acr√≥nimos sin explicar y conceptos complejos sin descomponer. Utiliza analog√≠as con cosas del d√≠a a d√≠a que cualquiera pueda entender (juguetes, comida, animales, familia). Divide informaci√≥n compleja en pasos peque√±os y digeribles. S√© paciente, claro y aseg√∫rate de que hasta un ni√±o pueda comprender la explicaci√≥n. Perfecto para principiantes absolutos, aprendizaje b√°sico o explicar temas complicados de forma accesible."
}

def get_user_config(user_id: int) -> Dict:
    """Obtiene la configuraci√≥n personalizada del usuario."""
    if user_id not in user_configs:
        user_configs[user_id] = {
            "mode": "üòä Casual",
            "temperature": TEMPERATURE,
            "model": OPENAI_MODEL,
            "max_tokens": MAX_TOKENS
        }
    return user_configs[user_id]

def get_system_prompt(user_id: int) -> str:
    """Genera el system prompt personalizado seg√∫n el modo del usuario."""
    config = get_user_config(user_id)
    mode = config["mode"]
    
    base_prompt = SYSTEM_PROMPT
    mode_instruction = RESPONSE_MODES.get(mode, RESPONSE_MODES["üòä Casual"])
    
    return f"{base_prompt} {mode_instruction}"

def get_main_keyboard():
    """Crea el teclado principal con botones de comandos."""
    keyboard = [
        [KeyboardButton("üÜò Ayuda"), KeyboardButton("üìä Estad√≠sticas")],
        [KeyboardButton("üîÑ Resetear Chat"), KeyboardButton("üí¨ Chat Libre")],
        [KeyboardButton("üé≠ Cambiar Modo"), KeyboardButton("‚öôÔ∏è Configuraci√≥n")]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)

def get_mode_keyboard():
    """Crea el teclado para seleccionar modo de respuesta."""
    keyboard = [
        [KeyboardButton("ü§ñ Formal"), KeyboardButton("üòä Casual")],
        [KeyboardButton("üéì Acad√©mico"), KeyboardButton("‚ö° Conciso")],
        [KeyboardButton("ÔøΩ Ejecutivo"), KeyboardButton("üé® Creativo")],
        [KeyboardButton("üë®‚Äçüíª T√©cnico"), KeyboardButton("üßí Simple")],
        [KeyboardButton("ÔøΩüîô Volver")]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)

def get_config_keyboard():
    """Crea el teclado para configuraci√≥n."""
    keyboard = [
        [KeyboardButton("üå°Ô∏è Temperatura"), KeyboardButton("üß† Modelo")],
        [KeyboardButton("üìè Tokens"), KeyboardButton("üìã Ver Config")],
        [KeyboardButton("üîô Volver")]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)

def get_temperature_keyboard():
    """Crea el teclado para seleccionar temperatura."""
    keyboard = [
        [KeyboardButton("üî• 0.1"), KeyboardButton("üå°Ô∏è 0.5"), KeyboardButton("üå°Ô∏è 0.7")],
        [KeyboardButton("üå°Ô∏è 1.0"), KeyboardButton("üå°Ô∏è 1.5"), KeyboardButton("üî• 2.0")],
        [KeyboardButton("üîô Volver Config")]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)

def get_model_keyboard():
    """Crea el teclado para seleccionar modelo."""
    keyboard = [
        [KeyboardButton("üß† gpt-4o"), KeyboardButton("‚ö° gpt-4o-mini")],
        [KeyboardButton("ÔøΩ gpt-3.5-turbo")],
        [KeyboardButton("ÔøΩüîô Volver Config")]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)

def get_tokens_keyboard():
    """Crea el teclado para seleccionar tokens."""
    keyboard = [
        [KeyboardButton("üìè 500"), KeyboardButton("üìè 1000")],
        [KeyboardButton("üìè 2000"), KeyboardButton("üìè 4000")],
        [KeyboardButton("üîô Volver Config")]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)

# ============================================================================
# FUNCIONES DE MANEJO DE ERRORES
# ============================================================================

def validate_user_config(config: dict) -> tuple[bool, str]:
    """Valida la configuraci√≥n del usuario."""
    try:
        # Validar temperatura
        if not (0.0 <= config.get("temperature", 0.7) <= 2.0):
            return False, "‚ùå La temperatura debe estar entre 0.0 y 2.0"
        
        # Validar modelo usando la lista centralizada
        if config.get("model") not in VALID_OPENAI_MODELS:
            return False, f"‚ùå Modelo no v√°lido. Usa: {', '.join(VALID_OPENAI_MODELS)}"
        
        # Validar tokens
        if not (50 <= config.get("max_tokens", 800) <= 4000):
            return False, "‚ùå Los tokens deben estar entre 50 y 4000"
        
        # Validar modo
        if config.get("mode") not in RESPONSE_MODES:
            return False, "‚ùå Modo de respuesta no v√°lido"
        
        return True, "‚úÖ Configuraci√≥n v√°lida"
    except Exception as e:
        return False, f"‚ùå Error validando configuraci√≥n: {str(e)}"

async def handle_openai_error(error: Exception, user_id: int) -> str:
    """Maneja errores espec√≠ficos de OpenAI y devuelve un mensaje amigable."""
    error_msg = str(error).lower()
    
    # Rate limiting
    if "rate limit" in error_msg or "too many requests" in error_msg:
        logger.warning(f"Rate limit para usuario {user_id}: {error}")
        return "‚è≥ **L√≠mite de uso alcanzado**\n\nEspera unos segundos antes de enviar otro mensaje.\n\nüí° Tip: Intenta reducir la frecuencia de mensajes."
    
    # Problemas de conexi√≥n
    if any(keyword in error_msg for keyword in ["connection", "timeout", "network"]):
        logger.warning(f"Problema de conexi√≥n para usuario {user_id}: {error}")
        return "üåê **Error de conexi√≥n**\n\nHay problemas temporales de conexi√≥n con la IA.\n\nüîÑ Intenta nuevamente en unos momentos."
    
    # Contexto muy largo
    if "context_length_exceeded" in error_msg or "maximum context length" in error_msg:
        logger.info(f"Contexto excedido para usuario {user_id}, limpiando historial")
        reset_history(user_id)
        return "üìö **Conversaci√≥n muy larga**\n\nHe limpiado el historial para continuar.\n\n‚ú® Puedes repetir tu √∫ltima pregunta."
    
    # Token inv√°lido o problemas de autenticaci√≥n
    if any(keyword in error_msg for keyword in ["authentication", "api key", "unauthorized"]):
        logger.error(f"Error de autenticaci√≥n OpenAI para usuario {user_id}: {error}")
        return "üîê **Error de configuraci√≥n**\n\nHay un problema con la configuraci√≥n del bot.\n\nüë®‚Äçüíª Contacta al administrador."
    
    # Contenido bloqueado
    if any(keyword in error_msg for keyword in ["content_filter", "policy", "safety"]):
        logger.warning(f"Contenido bloqueado para usuario {user_id}: {error}")
        return "üõ°Ô∏è **Contenido no permitido**\n\nTu mensaje no cumple con las pol√≠ticas de uso.\n\nüí≠ Intenta reformular tu pregunta de manera diferente."
    
    # Error gen√©rico
    logger.error(f"Error OpenAI no identificado para usuario {user_id}: {error}")
    return "ü§ñ **Error temporal de IA**\n\nHubo un problema t√©cnico inesperado.\n\nüîÑ Intenta nuevamente o usa /reset para empezar de nuevo."

async def safe_send_message(update: Update, message: str, reply_markup=None, max_retries: int = 3):
    """Env√≠a mensajes de forma segura con reintentos autom√°ticos."""
    for attempt in range(max_retries):
        try:
            await update.message.reply_text(
                message, 
                parse_mode='Markdown',
                reply_markup=reply_markup
            )
            return True
        except RetryAfter as e:
            if attempt < max_retries - 1:
                logger.warning(f"Rate limit Telegram, esperando {e.retry_after} segundos...")
                await asyncio.sleep(e.retry_after)
            else:
                logger.error(f"Rate limit Telegram agotado despu√©s de {max_retries} intentos")
        except BadRequest as e:
            if "can't parse" in str(e).lower():
                # Intenta enviar sin Markdown
                try:
                    await update.message.reply_text(message, reply_markup=reply_markup)
                    return True
                except Exception:
                    pass
            logger.error(f"BadRequest en Telegram: {e}")
        except (NetworkError, TimedOut) as e:
            if attempt < max_retries - 1:
                logger.warning(f"Error de red Telegram, reintentando... ({attempt + 1}/{max_retries})")
                await asyncio.sleep(2 ** attempt)  # Backoff exponencial
            else:
                logger.error(f"Error de red Telegram agotado: {e}")
        except Exception as e:
            logger.error(f"Error inesperado enviando mensaje: {e}")
            break
    
    # Si llegamos aqu√≠, fall√≥ todos los intentos
    try:
        # Intento final sin markdown ni teclado
        await update.message.reply_text("‚ùå Error enviando respuesta. Intenta nuevamente.")
    except Exception:
        logger.error("No se pudo enviar ni el mensaje de error")
    return False

def get_history(user_id: int) -> List[dict]:
    if user_id not in conversations:
        conversations[user_id] = [{"role": "system", "content": get_system_prompt(user_id)}]
    return conversations[user_id]

def reset_history(user_id: int):
    conversations[user_id] = [{"role": "system", "content": get_system_prompt(user_id)}]

def update_system_prompt(user_id: int):
    """Actualiza el system prompt cuando cambia el modo."""
    if user_id in conversations:
        history = conversations[user_id]
        if history and history[0]["role"] == "system":
            history[0]["content"] = get_system_prompt(user_id)

def trim_history(history: List[dict]) -> List[dict]:
    """Mantiene solo los √∫ltimos N mensajes para evitar exceder l√≠mites de tokens."""
    if len(history) <= MAX_HISTORY_MESSAGES:
        return history
    
    # Mantener el system prompt + √∫ltimos mensajes
    system_msg = history[0] if history and history[0]["role"] == "system" else None
    recent_messages = history[-(MAX_HISTORY_MESSAGES-1):] if system_msg else history[-MAX_HISTORY_MESSAGES:]
    
    if system_msg:
        return [system_msg] + recent_messages
    return recent_messages

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    
    # Verificar autorizaci√≥n
    if not is_user_authorized(user.id):
        await safe_send_message(
            update,
            f"‚ùå **No autorizado**\n\nTu ID de usuario es: `{user.id}`\n\nüë®‚Äçüíª Contacta al administrador para obtener acceso."
        )
        logger.warning(f"Usuario no autorizado intent√≥ usar el bot: {user.id} (@{user.username})")
        return
    
    try:
        reset_history(user.id)
        await safe_send_message(
            update,
            f"ü§ñ **¬°Hola {user.first_name}!** Soy tu asistente con OpenAI.\n\n"
            "üí¨ Puedes usar los botones de abajo o escribir directamente.\n"
            "üîÑ Usa los botones para acceder r√°pidamente a las funciones.\n"
            "‚ú® ¬°Empecemos a chatear!",
            get_main_keyboard()
        )
        logger.info(f"Usuario autorizado inici√≥ sesi√≥n: {user.id} (@{user.username})")
    except Exception as e:
        logger.error(f"Error iniciando sesi√≥n para usuario {user.id}: {e}")
        await safe_send_message(
            update,
            "‚ùå **Error iniciando**\n\nHubo un problema al inicializar tu sesi√≥n.\n\nüîÑ Intenta usar /start nuevamente."
        )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_user_authorized(user.id):
        return
    
    try:
        config = get_user_config(user.id)
        help_text = (
            "ü§ñ **Bot de Chat con OpenAI**\n\n"
            "**Botones principales:**\n"
            "‚Ä¢ üÜò Ayuda - Mostrar esta informaci√≥n\n"
            "‚Ä¢ üìä Estad√≠sticas - Ver tu uso del bot\n"
            "‚Ä¢ üîÑ Resetear Chat - Borrar conversaci√≥n\n"
            "‚Ä¢ üí¨ Chat Libre - Modo chat continuo\n"
            "‚Ä¢ üé≠ Cambiar Modo - Estilos de respuesta\n"
            "‚Ä¢ ‚öôÔ∏è Configuraci√≥n - Ajustes personalizados\n\n"
            "**Modos de respuesta:**\n"
            "‚Ä¢ ü§ñ Formal - Profesional y corporativo\n"
            "‚Ä¢ üòä Casual - Amigable y conversacional\n"
            "‚Ä¢ üéì Acad√©mico - Detallado y educativo\n"
            "‚Ä¢ ‚ö° Conciso - Breve y directo\n"
            "‚Ä¢ üíº Ejecutivo - Resumen ejecutivo\n"
            "‚Ä¢ üé® Creativo - Imaginativo y expresivo\n"
            "‚Ä¢ üë®‚Äçüíª T√©cnico - Especializado y t√©cnico\n"
            "‚Ä¢ üßí Simple - F√°cil de entender\n\n"
            "**üìÑ Soporte de Documentos:**\n"
            "Env√≠a archivos y te ayudo a analizarlos:\n"
            "‚Ä¢ üìï PDF - Extrae y analiza texto\n"
            "‚Ä¢ üìÑ TXT - Lee archivos de texto\n"
            "‚Ä¢ üìò Word (.docx, .doc) - Analiza documentos\n"
            "‚Ä¢ üìä Excel (.xlsx, .xls) - Lee hojas de c√°lculo\n"
            "‚Ä¢ üìã CSV - Procesa datos tabulares\n\n"
            "**Comandos de configuraci√≥n:**\n"
            "‚Ä¢ `/config temperatura 0.8` - Cambiar creatividad\n"
            "‚Ä¢ `/config modelo gpt-4o` - Cambiar modelo\n"
            "‚Ä¢ `/config tokens 500` - Cambiar l√≠mite\n\n"
            f"**Tu configuraci√≥n actual:**\n"
            f"‚Ä¢ Modo: {config['mode']}\n"
            f"‚Ä¢ Modelo: {config['model']}\n"
            f"‚Ä¢ Temperatura: {config['temperature']}\n"
            f"‚Ä¢ M√°x. tokens: {config['max_tokens']}\n"
            f"‚Ä¢ M√°x. historial: {MAX_HISTORY_MESSAGES}\n\n"
            "üí° Usa los botones o escribe directamente."
        )
        await safe_send_message(update, help_text, get_main_keyboard())
    except Exception as e:
        logger.error(f"Error mostrando ayuda a usuario {user.id}: {e}")
        await safe_send_message(
            update,
            "‚ùå **Error**\n\nNo se pudo cargar la informaci√≥n de ayuda.\n\nüîÑ Intenta nuevamente.",
            get_main_keyboard()
        )

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_user_authorized(user.id):
        return
    
    try:
        user_history = get_history(user.id)
        total_users = len(conversations)
        user_messages = len([msg for msg in user_history if msg["role"] == "user"])
        
        stats_text = (
            f"üìä **Estad√≠sticas**\n\n"
            f"üë§ **Tu sesi√≥n:**\n"
            f"‚Ä¢ Mensajes enviados: {user_messages}\n"
            f"‚Ä¢ Contexto actual: {len(user_history)} mensajes\n\n"
            f"üåê **Global:**\n"
            f"‚Ä¢ Usuarios activos: {total_users}\n"
            f"‚Ä¢ Modelo en uso: {OPENAI_MODEL}"
        )
        await safe_send_message(update, stats_text, get_main_keyboard())
    except Exception as e:
        logger.error(f"Error generando estad√≠sticas para usuario {user.id}: {e}")
        await safe_send_message(
            update,
            "‚ùå **Error**\n\nNo se pudieron cargar las estad√≠sticas.\n\nüîÑ Intenta nuevamente.",
            get_main_keyboard()
        )

async def reset(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_user_authorized(user.id):
        return
    
    try:
        reset_history(user.id)
        await safe_send_message(
            update,
            "üßπ **Chat reiniciado**\n\nContexto borrado exitosamente.\n\n‚ú® Empecemos de nuevo.",
            get_main_keyboard()
        )
        logger.info(f"Usuario {user.id} reinici√≥ su chat")
    except Exception as e:
        logger.error(f"Error reiniciando chat para usuario {user.id}: {e}")
        await safe_send_message(
            update,
            "‚ùå **Error**\n\nNo se pudo reiniciar el chat.\n\nüîÑ Intenta nuevamente.",
            get_main_keyboard()
        )

async def config_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Maneja el comando /config para cambiar configuraciones."""
    user = update.effective_user
    if not is_user_authorized(user.id):
        return
    
    try:
        if not context.args or len(context.args) < 2:
            config = get_user_config(user.id)
            config_text = (
                f"‚öôÔ∏è **Tu configuraci√≥n actual:**\n\n"
                f"üé≠ **Modo:** {config['mode']}\n"
                f"üå°Ô∏è **Temperatura:** {config['temperature']}\n"
                f"üß† **Modelo:** {config['model']}\n"
                f"üìè **Tokens:** {config['max_tokens']}\n\n"
                "**Para cambiar usa:**\n"
                "`/config temperatura 0.8`\n"
                "`/config modelo gpt-4o`\n"
                "`/config tokens 500`\n\n"
                "**Valores permitidos:**\n"
                "‚Ä¢ Temperatura: 0.0 - 2.0\n"
                f"‚Ä¢ Modelo: {', '.join(VALID_OPENAI_MODELS)}\n"
                "‚Ä¢ Tokens: 100 - 4000"
            )
            await safe_send_message(update, config_text, get_main_keyboard())
            return
        
        setting = context.args[0].lower()
        value = context.args[1]
        config = get_user_config(user.id)
        
        if setting == "temperatura":
            try:
                temp = float(value)
                if 0.0 <= temp <= 2.0:
                    config["temperature"] = temp
                    user_configs[user.id] = config
                    desc = 'üé® M√°s creativo' if temp > 1.0 else 'üéØ M√°s preciso' if temp < 0.5 else '‚öñÔ∏è Equilibrado'
                    await safe_send_message(
                        update,
                        f"‚úÖ **Temperatura actualizada**\n\nüå°Ô∏è **Valor:** {temp} ({desc})",
                        get_main_keyboard()
                    )
                else:
                    await safe_send_message(
                        update,
                        "‚ùå **Temperatura inv√°lida**\n\nDebe estar entre 0.0 y 2.0\n\nüí° Ejemplo: `/config temperatura 0.7`",
                        get_main_keyboard()
                    )
            except ValueError:
                await safe_send_message(
                    update,
                    "‚ùå **Formato inv√°lido**\n\nLa temperatura debe ser un n√∫mero.\n\nüí° Ejemplo: `/config temperatura 0.7`",
                    get_main_keyboard()
                )
                    
        elif setting == "modelo":
            if value in VALID_OPENAI_MODELS:
                config["model"] = value
                user_configs[user.id] = config
                desc = "M√°s inteligente" if value == "gpt-4o" else "R√°pido y econ√≥mico" if value == "gpt-4o-mini" else "B√°sico y econ√≥mico"
                await safe_send_message(
                    update,
                    f"‚úÖ **Modelo actualizado**\n\nüß† **Modelo:** {value}\nüìä **Tipo:** {desc}",
                    get_main_keyboard()
                )
            else:
                await safe_send_message(
                    update,
                    f"‚ùå **Modelo inv√°lido**\n\nModelos disponibles:\n‚Ä¢ {chr(10).join(VALID_OPENAI_MODELS)}\n\nüí° Ejemplo: `/config modelo gpt-4o-mini`",
                    get_main_keyboard()
                )
                    
        elif setting == "tokens":
            try:
                tokens = int(value)
                if 100 <= tokens <= 4000:
                    config["max_tokens"] = tokens
                    user_configs[user.id] = config
                    length = "cortas" if tokens <= 500 else "medianas" if tokens <= 1000 else "largas" if tokens <= 2000 else "muy largas"
                    await safe_send_message(
                        update,
                        f"‚úÖ **Tokens actualizados**\n\nüìè **L√≠mite:** {tokens}\nüìù **Respuestas:** {length}",
                        get_main_keyboard()
                    )
                else:
                    await safe_send_message(
                        update,
                        "‚ùå **Tokens inv√°lidos**\n\nDeben estar entre 100 y 4000\n\nüí° Ejemplo: `/config tokens 500`",
                        get_main_keyboard()
                    )
            except ValueError:
                await safe_send_message(
                    update,
                    "‚ùå **Formato inv√°lido**\n\nLos tokens deben ser un n√∫mero entero.\n\nüí° Ejemplo: `/config tokens 500`",
                    get_main_keyboard()
                )
                    
        else:
            await safe_send_message(
                update,
                "‚ùå **Configuraci√≥n no v√°lida**\n\nOpciones disponibles:\n‚Ä¢ temperatura\n‚Ä¢ modelo\n‚Ä¢ tokens\n\nüí° Ejemplo: `/config temperatura 0.7`",
                get_main_keyboard()
            )
    
    except Exception as e:
        logger.error(f"Error en config_command para usuario {user.id}: {e}")
        await safe_send_message(
            update,
            "‚ùå **Error de configuraci√≥n**\n\nHubo un problema procesando tu comando.\n\nüîÑ Intenta nuevamente o usa los botones del men√∫.",
            get_main_keyboard()
        )

async def mode_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Maneja el cambio de modo de respuesta."""
    user = update.effective_user
    if not is_user_authorized(user.id):
        return
    
    try:
        text = update.message.text
        config = get_user_config(user.id)
        
        if text in RESPONSE_MODES:
            old_mode = config["mode"]
            config["mode"] = text
            user_configs[user.id] = config
            update_system_prompt(user.id)
            
            mode_description = RESPONSE_MODES[text]
            await safe_send_message(
                update,
                f"‚úÖ **Modo cambiado**\n\n"
                f"üîÑ **De:** {old_mode}\n"
                f"‚û°Ô∏è **A:** {text}\n\n"
                f"üìù **Descripci√≥n:** {mode_description}\n\n"
                "üí° Los pr√≥ximos mensajes seguir√°n este estilo.",
                get_main_keyboard()
            )
            logger.info(f"Usuario {user.id} cambi√≥ modo de {old_mode} a {text}")
        else:
            await safe_send_message(
                update,
                "‚ùå **Modo no v√°lido**\n\nUsa el men√∫ de modos o los botones disponibles.",
                get_mode_keyboard()
            )
    
    except Exception as e:
        logger.error(f"Error en mode_handler para usuario {user.id}: {e}")
        await safe_send_message(
            update,
            "‚ùå **Error cambiando modo**\n\nHubo un problema procesando el cambio.\n\nüîÑ Intenta nuevamente.",
            get_main_keyboard()
        )

async def handle_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Maneja los botones del teclado personalizado."""
    user = update.effective_user
    if not is_user_authorized(user.id):
        return
    
    text = update.message.text
    
    # Botones principales
    if text == "üÜò Ayuda":
        await help_command(update, context)
    elif text == "üìä Estad√≠sticas":
        await stats_command(update, context)
    elif text == "üîÑ Resetear Chat":
        await reset(update, context)
    elif text == "üí¨ Chat Libre":
        await update.message.reply_text(
            "üí¨ **Modo Chat Libre Activado**\n\n"
            "Ahora puedes escribir cualquier mensaje y te responder√©.\n"
            "‚ú® La conversaci√≥n continuar√° con contexto.\n"
            "üîÑ Usa el bot√≥n 'Resetear Chat' para empezar de nuevo.",
            parse_mode='Markdown',
            reply_markup=get_main_keyboard()
        )
    elif text == "üé≠ Cambiar Modo":
        config = get_user_config(user.id)
        await update.message.reply_text(
            f"üé≠ **Selecciona un modo de respuesta:**\n\n"
            f"**Actual:** {config['mode']}\n\n"
            "ü§ñ **Formal** - Profesional y corporativo\n"
            "üòä **Casual** - Amigable como un amigo\n"
            "üéì **Acad√©mico** - Detallado y t√©cnico\n"
            "‚ö° **Conciso** - Breve y directo\n"
            "üíº **Ejecutivo** - Resumen ejecutivo\n"
            "üé® **Creativo** - Imaginativo y expresivo\n"
            "üë®‚Äçüíª **T√©cnico** - Especializado y preciso\n"
            "üßí **Simple** - F√°cil de entender",
            parse_mode='Markdown',
            reply_markup=get_mode_keyboard()
        )
    elif text == "‚öôÔ∏è Configuraci√≥n":
        await update.message.reply_text(
            "‚öôÔ∏è **Panel de Configuraci√≥n**\n\n"
            "Selecciona qu√© quieres ajustar:\n\n"
            "üå°Ô∏è **Temperatura** - Creatividad vs Precisi√≥n\n"
            "üß† **Modelo** - Capacidad de OpenAI\n"
            "üìè **Tokens** - Longitud de respuestas\n"
            "üìã **Ver Config** - Configuraci√≥n actual",
            parse_mode='Markdown',
            reply_markup=get_config_keyboard()
        )
    elif text == "üîô Volver":
        await update.message.reply_text(
            "üîô **Men√∫ Principal**\n\nSelecciona una opci√≥n:",
            reply_markup=get_main_keyboard()
        )
    
    # Botones de configuraci√≥n
    elif text == "üå°Ô∏è Temperatura":
        config = get_user_config(user.id)
        temp_desc = "üé® Creativo" if config["temperature"] > 1.0 else "üéØ Preciso" if config["temperature"] < 0.5 else "‚öñÔ∏è Equilibrado"
        await update.message.reply_text(
            f"üå°Ô∏è **Temperatura actual:** {config['temperature']} ({temp_desc})\n\n"
            "**Selecciona un valor:**\n\n"
            "üî• **0.1** - Muy preciso y determinista\n"
            "üå°Ô∏è **0.5** - Equilibrado hacia precisi√≥n\n"
            "üå°Ô∏è **0.7** - Equilibrado (recomendado)\n"
            "üå°Ô∏è **1.0** - Creativo moderado\n"
            "üå°Ô∏è **1.5** - Muy creativo\n"
            "ÔøΩ **2.0** - M√°xima creatividad",
            parse_mode='Markdown',
            reply_markup=get_temperature_keyboard()
        )
    elif text == "üß† Modelo":
        config = get_user_config(user.id)
        await update.message.reply_text(
            f"üß† **Modelo actual:** {config['model']}\n\n"
            "**Selecciona un modelo:**\n\n"
            "üß† **gpt-4o** - M√°s inteligente y capaz\n"
            "‚ö° **gpt-4o-mini** - R√°pido y econ√≥mico\n"
            "üî∑ **gpt-3.5-turbo** - B√°sico y econ√≥mico\n\n"
            "üí° gpt-4o es m√°s capaz pero usa m√°s tokens",
            parse_mode='Markdown',
            reply_markup=get_model_keyboard()
        )
    elif text == "üìè Tokens":
        config = get_user_config(user.id)
        await update.message.reply_text(
            f"üìè **Tokens actuales:** {config['max_tokens']}\n\n"
            "**Selecciona la longitud:**\n\n"
            "üìè **500** - Respuestas cortas\n"
            "üìè **1000** - Respuestas medianas\n"
            "üìè **2000** - Respuestas largas\n"
            "üìè **4000** - Respuestas muy largas\n\n"
            "üí° M√°s tokens = respuestas m√°s detalladas",
            parse_mode='Markdown',
            reply_markup=get_tokens_keyboard()
        )
    elif text == "üìã Ver Config":
        await config_command(update, context)
    elif text == "üîô Volver Config":
        await update.message.reply_text(
            "‚öôÔ∏è **Panel de Configuraci√≥n**\n\n"
            "Selecciona qu√© quieres ajustar:",
            parse_mode='Markdown',
            reply_markup=get_config_keyboard()
        )
    
    # Opciones de temperatura
    elif text in ["üî• 0.1", "üå°Ô∏è 0.5", "üå°Ô∏è 0.7", "üå°Ô∏è 1.0", "üå°Ô∏è 1.5", "üî• 2.0"]:
        temp_value = float(text.split()[-1])
        config = get_user_config(user.id)
        config["temperature"] = temp_value
        user_configs[user.id] = config
        
        temp_desc = "üé® Creativo" if temp_value > 1.0 else "üéØ Preciso" if temp_value < 0.5 else "‚öñÔ∏è Equilibrado"
        await update.message.reply_text(
            f"‚úÖ **Temperatura actualizada**\n\n"
            f"üå°Ô∏è **Nuevo valor:** {temp_value} ({temp_desc})\n"
            f"üìà Las pr√≥ximas respuestas tendr√°n este nivel de creatividad.",
            parse_mode='Markdown',
            reply_markup=get_config_keyboard()
        )
    
    # Opciones de modelo
    elif text in ["üß† gpt-4o", "‚ö° gpt-4o-mini", "üî∑ gpt-3.5-turbo"]:
        model_value = text.split()[-1]
        config = get_user_config(user.id)
        config["model"] = model_value
        user_configs[user.id] = config
        
        model_desc = "M√°s inteligente y capaz" if model_value == "gpt-4o" else "R√°pido y econ√≥mico" if model_value == "gpt-4o-mini" else "B√°sico y econ√≥mico"
        await update.message.reply_text(
            f"‚úÖ **Modelo actualizado**\n\n"
            f"üß† **Nuevo modelo:** {model_value}\n"
            f"üìä **Caracter√≠sticas:** {model_desc}",
            parse_mode='Markdown',
            reply_markup=get_config_keyboard()
        )
    
    # Opciones de tokens
    elif text in ["üìè 500", "üìè 1000", "üìè 2000", "üìè 4000"]:
        tokens_value = int(text.split()[-1])
        config = get_user_config(user.id)
        config["max_tokens"] = tokens_value
        user_configs[user.id] = config
        
        length_desc = "cortas" if tokens_value <= 500 else "medianas" if tokens_value <= 1000 else "largas" if tokens_value <= 2000 else "muy largas"
        await update.message.reply_text(
            f"‚úÖ **Tokens actualizados**\n\n"
            f"üìè **Nuevo l√≠mite:** {tokens_value} tokens\n"
            f"üìù **Respuestas:** {length_desc}",
            parse_mode='Markdown',
            reply_markup=get_config_keyboard()
        )
    
    # Modos de respuesta
    elif text in RESPONSE_MODES:
        await mode_handler(update, context)
    
    else:
        # Si no es un bot√≥n conocido, tratarlo como mensaje normal
        await chat(update, context)

async def chat(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not update.message or not update.message.text:
        return
    
    # Verificar autorizaci√≥n
    if not is_user_authorized(user.id):
        await safe_send_message(
            update, 
            f"‚ùå **No autorizado**\n\nTu ID de usuario es: `{user.id}`\n\nüë®‚Äçüíª Contacta al administrador."
        )
        return
    
    text = update.message.text.strip()
    if not text:
        return

    # A√±adir mensaje del usuario al historial
    try:
        history = get_history(user.id)
        history.append({"role": "user", "content": text})
        
        # Recortar historial si es muy largo
        history = trim_history(history)
        conversations[user.id] = history
    except Exception as e:
        logger.error(f"Error manejando historial para usuario {user.id}: {e}")
        await safe_send_message(
            update, 
            "‚ùå **Error interno**\n\nHubo un problema guardando tu mensaje.\n\nüîÑ Intenta usar /reset"
        )
        return

    # Indicador de escritura con manejo de errores
    try:
        await update.message.chat.send_action(action=ChatAction.TYPING)
    except Exception as e:
        logger.warning(f"No se pudo mostrar indicador de escritura para usuario {user.id}: {e}")
        # No es cr√≠tico, contin√∫amos

    # Obtener y validar configuraci√≥n personalizada del usuario
    try:
        config = get_user_config(user.id)
        is_valid, validation_msg = validate_user_config(config)
        
        if not is_valid:
            logger.warning(f"Configuraci√≥n inv√°lida para usuario {user.id}: {validation_msg}")
            # Resetear a configuraci√≥n por defecto
            user_configs[user.id] = {
                "mode": "üòä Casual",
                "temperature": 0.7,
                "model": "gpt-4o-mini",
                "max_tokens": 500
            }
            config = get_user_config(user.id)
            await safe_send_message(
                update,
                f"‚ö†Ô∏è **Configuraci√≥n corregida**\n\n{validation_msg}\n\nüîß He aplicado valores por defecto."
            )
    except Exception as e:
        logger.error(f"Error obteniendo configuraci√≥n para usuario {user.id}: {e}")
        await safe_send_message(
            update, 
            "‚ùå **Error de configuraci√≥n**\n\nUsa /reset para restaurar configuraci√≥n por defecto."
        )
        return

    # Llamada a OpenAI con manejo de errores robusto
    try:
        resp = client.chat.completions.create(
            model=config["model"],
            messages=history,
            temperature=config["temperature"],
            max_tokens=config["max_tokens"],
            timeout=30  # Timeout de 30 segundos
        )
        
        answer = (resp.choices[0].message.content or "").strip()
        if not answer:
            answer = "ü§î La IA no gener√≥ una respuesta. Intenta reformular tu pregunta."
        
        logger.info(f"Respuesta generada para usuario {user.id}: {len(answer)} caracteres | Modo: {config['mode']} | Modelo: {config['model']}")
        
        # A√±adir respuesta al historial
        history.append({"role": "assistant", "content": answer})
        conversations[user.id] = history
        
    except openai.RateLimitError as e:
        error_msg = await handle_openai_error(e, user.id)
        await safe_send_message(update, error_msg, get_main_keyboard())
        return
        
    except openai.APIConnectionError as e:
        error_msg = await handle_openai_error(e, user.id)
        await safe_send_message(update, error_msg, get_main_keyboard())
        return
        
    except openai.APITimeoutError as e:
        logger.warning(f"Timeout OpenAI para usuario {user.id}: {e}")
        await safe_send_message(
            update,
            "‚è∞ **Timeout**\n\nLa IA tard√≥ demasiado en responder.\n\nüîÑ Intenta con una pregunta m√°s simple.",
            get_main_keyboard()
        )
        return
        
    except openai.AuthenticationError as e:
        error_msg = await handle_openai_error(e, user.id)
        await safe_send_message(update, error_msg, get_main_keyboard())
        return
        
    except openai.BadRequestError as e:
        error_msg = await handle_openai_error(e, user.id)
        await safe_send_message(update, error_msg, get_main_keyboard())
        return
        
    except Exception as e:
        error_msg = await handle_openai_error(e, user.id)
        await safe_send_message(update, error_msg, get_main_keyboard())
        return

    # Enviar respuesta con manejo de errores
    try:
        success = await safe_send_message(update, answer, get_main_keyboard())
        if not success:
            logger.error(f"No se pudo enviar respuesta a usuario {user.id} despu√©s de varios intentos")
    except Exception as e:
        logger.error(f"Error cr√≠tico enviando respuesta a usuario {user.id}: {e}")

async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Maneja documentos enviados por los usuarios."""
    user = update.effective_user
    
    # Verificar autorizaci√≥n
    if not is_user_authorized(user.id):
        await safe_send_message(
            update, 
            f"‚ùå **No autorizado**\n\nTu ID de usuario es: `{user.id}`\n\nüë®‚Äçüíª Contacta al administrador."
        )
        return
    
    try:
        # Obtener el documento
        document = update.message.document
        
        if not document:
            return
        
        filename = document.file_name
        file_size_mb = document.file_size / (1024 * 1024)
        
        # Verificar si el formato es soportado
        if not document_handler.is_supported(filename):
            await safe_send_message(
                update,
                f"‚ùå **Formato no soportado**\n\n"
                f"üìÑ Archivo: `{filename}`\n\n"
                f"**Formatos soportados:**\n{document_handler.get_supported_formats()}\n\n"
                "üí° Env√≠a un archivo en uno de estos formatos.",
                get_main_keyboard()
            )
            return
        
        # Notificar que se est√° procesando
        await safe_send_message(
            update,
            f"üìÑ **Procesando documento...**\n\n"
            f"üìé Archivo: `{filename}`\n"
            f"üìä Tama√±o: {file_size_mb:.2f} MB\n\n"
            "‚è≥ Extrayendo contenido..."
        )
        
        # Indicador de procesamiento
        await update.message.chat.send_action(action=ChatAction.TYPING)
        
        # Descargar archivo
        file = await context.bot.get_file(document.file_id)
        file_bytes = await file.download_as_bytearray()
        
        # Procesar documento
        success, message, content = await document_handler.process_document(bytes(file_bytes), filename)
        
        if not success:
            await safe_send_message(update, message, get_main_keyboard())
            return
        
        # Documento procesado exitosamente
        logger.info(f"Documento procesado para usuario {user.id}: {filename} ({len(content)} chars)")
        
        # Agregar el contenido al contexto
        history = get_history(user.id)
        
        # Crear mensaje con el contenido del documento
        doc_message = f"[Usuario envi√≥ el documento '{filename}'. Contenido del documento:\n\n{content}\n\n]"
        history.append({"role": "user", "content": doc_message})
        
        # Pedir al usuario qu√© quiere hacer con el documento
        prompt = "He procesado tu documento. ¬øQu√© te gustar√≠a saber sobre √©l? Puedes pedirme:\n- Resumen del contenido\n- Responder preguntas espec√≠ficas\n- Extraer informaci√≥n particular\n- Traducir el documento\n- Analizar datos (si es Excel/CSV)"
        history.append({"role": "assistant", "content": prompt})
        
        conversations[user.id] = history
        
        await safe_send_message(
            update,
            f"‚úÖ **Documento procesado**\n\n"
            f"üìÑ {filename}\n"
            f"üìù {len(content)} caracteres extra√≠dos\n\n"
            f"{prompt}",
            get_main_keyboard()
        )
        
    except Exception as e:
        logger.error(f"Error manejando documento para usuario {user.id}: {e}")
        await safe_send_message(
            update,
            "‚ùå **Error procesando documento**\n\n"
            f"Hubo un problema al procesar el archivo.\n\n"
            f"Detalles: {str(e)[:100]}",
            get_main_keyboard()
        )

def main():
    """Funci√≥n principal con manejo de errores robusto."""
    try:
        # Validar configuraci√≥n inicial
        logger.info("üîß Iniciando validaci√≥n de configuraci√≥n...")
        ensure_config()
        logger.info("‚úÖ Configuraci√≥n validada exitosamente")
        
        # Crear aplicaci√≥n Telegram
        logger.info("üì± Creando aplicaci√≥n Telegram...")
        app = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
        logger.info("‚úÖ Aplicaci√≥n Telegram creada")

        # Registrar comandos
        logger.info("üìã Registrando comandos...")
        app.add_handler(CommandHandler("start", start))
        app.add_handler(CommandHandler("reset", reset))
        app.add_handler(CommandHandler("help", help_command))
        app.add_handler(CommandHandler("stats", stats_command))
        app.add_handler(CommandHandler("config", config_command))

        # Manejo de documentos
        app.add_handler(MessageHandler(filters.Document.ALL, handle_document))
        
        # Manejo de botones y chat general
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_buttons))
        logger.info("‚úÖ Handlers registrados exitosamente")

        logger.info("ü§ñ Chat Bot con OpenAI iniciado")
        logger.info(f"üîí Usuarios autorizados: {len([id for id in [1, 2] if is_user_authorized(id)])}")
        logger.info("üöÄ Bot ejecut√°ndose... (Ctrl+C para detener)")
        
        # Iniciar bot
        app.run_polling()
        
    except KeyboardInterrupt:
        logger.info("‚èπÔ∏è Bot detenido por el usuario")
    except Exception as e:
        logger.critical(f"üí• Error cr√≠tico al iniciar el bot: {e}")
        logger.critical("üîç Verifica tu configuraci√≥n y conexi√≥n a internet")
        
        # Informaci√≥n de diagn√≥stico
        logger.error("‚ùå Verifica tu configuraci√≥n:")
        logger.error("  ‚Ä¢ TOKEN de Telegram en config/settings.py")
        logger.error("  ‚Ä¢ API Key de OpenAI configurada")
        logger.error("  ‚Ä¢ Conexi√≥n a internet disponible")
            
        raise  # Re-lanzar el error para debugging

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"\nüí• ERROR CR√çTICO: {e}")
        print("üîß Revisa los logs para m√°s detalles")
        print("üìñ Consulta la documentaci√≥n del bot")
        exit(1)
